# Java编译过程分析

`Java`编译主要是指从`java`源文件到`class`字节码文件的翻译过程，这一过程由`javac`来完成；`class`字节码文件可以由`JVM`(`Java`虚拟机)直接解释执行，因此很多地方都称`Java`是一种半编译，半解释执行的语言，但是随着`JIT`技术的出现，这种说法后半部分就有些错误了。这里我们主要关注前半段由`java`源文件到`class`字节码文件的翻译过程，即`java`前端编译的过程，概括而言，这一阶段包括**词法分析**、**语法分析**、**填充符号表**、**语义分析**以及**字节码生成**五个步骤。

## 词法分析

**词法分析**是将`java`源代码字符序列转换为`Token`序列的过程。单个字符是代码编写过程的最小单位，而单个`Token`则是代码编译过程中的最小单位，其中**关键字**、**变量名**、**字面量**以及**运算符**等都可以称为`Token`。例如，下面这行代码：

```java
String say = "Hello World!";
```

这行代码包含了`4`个`Token`，分别是关键字`String`、变量名`say`、运算符`=`以及字面量`"Hello World!"`。其中`String`、`say`以及`"Hello World!"`都由多个字符组成，但是它们都只能称为一个`Token`，不可划分。

**词法分析过程**是一个被动过程，被**语法分析器**(`Parser`)调用用来辅助生成**抽象语法树**。

## 语法分析

**语法分析**是利用**词法分析过程**生成的`Token`序列来构建更加结构化的**抽象语法树**的过程。**抽象语法树**是对`java`源代码程序结构的树形表示，之所以称为**抽象语法树**而不仅仅是**语法树**，是因为它并不会反应出`java`源代码语法结构的每一处真实细节，例如，嵌套括号被隐含在了树的结构中，而不会以树的节点的方式呈现出来。

**语法分析器**构建**抽象语法树**的过程中采用的是上下文无关的文法，也就是说当成功构建出**抽象语法树**的时候就表示`java`源代码在语法结构上是正确的，但是它并不能说明`java`源代码在逻辑上也是正确的，对于`java`源代码逻辑结构的审查将在**语义分析阶段**进行。

经过**语法分析**阶段之后，编译器就基本不会再对`java`源码文件进行操作了，后续的步骤都建立在**抽象语法树**之上。

## 填充符号表

**符号表**是由一组符号地址和符号信息构成的表格。**符号表**中所记录的信息在之后的各个阶段都将被用到，例如，在**语义分析**阶段，符号表中所记录的信息会被用于语义检查及产生中间代码，而在**字节码生成**阶段，当对符号名进行地址分配时，**符号表**就是地址分配的依据。

一个类除了本身会定义一些符号如类名、属性名、方法名之外，还有引用其它类的符号，这些符号会调用其它类的方法或者属性等，另外一个类还可能会继承父类以及实现接口。所有不是由该类本身所定义的符号都一定在其它类中有定义，那么这些类的符号也会被解析到符号表中。也就是说`java`源代码文件在编译过程中是相互依赖的，这也是为什么`java`没有分布式编译解决方案的原因之一。

符号表中记录的信息通常是标识符(`identifier`)的相关信息，如其类型、作用域等。这些信息被用来在**语义分析阶段**对源代码做逻辑检查使用，例如在**语法分析阶段**对于下面这种情况是不会报错的：

```java
int i;
i = "Hello World!";
```

因为这个代码片段在语法结构上是正确的，**语法分析阶段**使用上下文无关文法而无法识别出类型不匹配的错误，但在**语义分析阶段**利用**符号表**记录的标识符的相关信息可以很容易发现这种逻辑错误。

## 语义分析

抽象语法树可以表示一个结构正确的源程序的抽象，但却无法保证源程序在逻辑上也是符合的。语义分析的主要工作就是读取结构上正确的源程序进行上下文相关性质的审查。

**语义分析阶段**主要包括**标注检查**和**数据及控制流分析**两个步骤：

* **标注检查**主要检查变量使用前是否有定义、变量参与运算时，有没有超出作用域以及相关数据类型是否与前面变量定义时的类型相匹配等；
* **数据及控制流分析**是对源程序的上下文逻辑做进一步的验证，它会检查局部变量在使用前是否已经赋值（全局变量和静态变量都有默认值，所以不会被检查）、方法的每一条路径是否都有返回值、所有的受查异常是否都已被正确处理等问题；

## 字节码生成

**字节码生成**是`javac`编译的最后一个阶段，此过程会把抽象语法树所抽象出来的语法结构按照`class`二进制字节码的规则排布成`class`字节码，并最终写入到磁盘上。但是这个过程并非仅仅只有代码转换工作，`javac`编译器还会在此阶段进行少量的代码添加以及初级的优化等工作，例如类构造器`<init>()`和实例构造器`<clinit>()`就是在这一阶段被添加到抽象语法树上的。

> 构造器不是构造函数，构造函数是在**填充符号表**阶段完成的，构造函数用于完成`new`操作，而构造器则是用于在内存中构造出类的基本结构。构造函数是语法层级较高的操作，会将静态代码块`static{}`加入类构造器，将构造代码块`{}`加入实例构造器，包括实例变量以及类变量的初始化、父类构造器的调用等过程都加入到构造器中去。

上面的过程完成后，`javac`编译器就将`java`源代码转化成了`class`字节码用于`JVM`去解释执行。
